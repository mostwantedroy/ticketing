
1. 공연 예매 비즈니스 상, 많은 예매 요청이 한번에 요청될 가능성이 높으므로, DB 단의 비관적 락이나 낙관적 락은 성능상으로 이슈가 생길 것 같다고 판단했습니다. 그러므로 Application에서 `Redis`를 활용해 `분산 락`을 걸어서 해결하는 방향으로 좋겠다고 판단했습니다. 
    
2. Spring 기반 Redis 라이브러리는 Redisson과 Lettuce이 있습니다. Redisson은 pub-sub 방식으로, Lettuce는 spin lock 방식으로 Redis를 사용합니다. spin lock 방식에서는 동시에 수많은 스레드가 lock을 획득하기 위한 대기 상태가 발생할 경우, Redis에 부하가 발생할 수 있습니다. pub-sub 방식의 경우, lock이 해제되면 다른 스레드가 바로 lock을 획득할 수 있으므로, 상대적으로 더 적은 부하를 받게 됩니다. 성능 상의 이점을 생각했을 때, Redisson을 사용하기로 했습니다. 
    
3. 동시성 이슈가 생길 수 있는 데이터는 예약좌석(reservationSeat)과 performance의 capacity 데이터입니다. 두 데이터에 performance와 독립적으로 Lock을 걸어버리면 동시성 이슈를 해결할 수 있다고 생각했고, Lock의 key는 **`Performance:”performanceId”`** 과 같이 결정했습니다. 
    
4. Test Code 상으로 처음에 진행했을 때는 performance의 remain capacity가 실제 요청 받은 capacity가 다른 경우가 존재했습니다. 어떤 부분이 문제였을까 둘러본 결과, 비즈니스 로직에서의 트랜잭션 범위가 문제였습니다. 비즈니스 로직 내부에 Lock를 거는 바람에 트랜잭션이 커밋되기 전에 다른 스레드의 요청이 처리되어, 동시성이 깨지는 현상이 발생했습니다. 아래 Flow와 같이, Lock을 먼저 건 다음, 트랜잭션이 사용된 비즈니스 로직을 사용하여 문제를 해결했습니다. 

- Lock 획득
- Transaction 시작
- reservation logic 처리
- Transaction 커밋
- Lock 반납